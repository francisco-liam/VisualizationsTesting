#pragma kernel FunctionKernel

//struct to hold individual ship data
struct ShipData
{
    float3 position;
    float3 velocity;
    float3 movePosition;
    float heading;
};

//parameters
int numShips; //total number of ships
int entity; //index of the entity the graph is made for in EntityMgr.inst.entities
int entCommands; //number of commands in the main ent
float maxMag; //maximum magnitude of potentials to be represented on the graph
bool logarthmic;

//parameters for the fields from the AIMgr
float waypointCoefficient;
float waypointExponent;
float attractiveCoefficient;
float attractiveExponent;
float repulsiveCoefficient;
float repulsiveExponent;
float bearingAngle;
float bearingAngleExp;
float bearingCoefficient;
float bearingExponent;
float taAngle;
float taAngleExp;
float taCoefficient;
float taExponent;

//parameters to toggle fields
bool calcWaypoint;
bool calcRepField;
bool calcAttField;
bool calcCrossPosField;
bool calcCrossVelField;

RWStructuredBuffer<float3> positions; //buffer to hold mesh vertex positions
StructuredBuffer<ShipData> ships; //buffer to hold indvidual ship data


//Same as the Vector3.normalize method in unity
float3 NormalizeVector(float3 vec)
{
    float mag = sqrt(vec.x * vec.x + vec.y * vec.y + vec.z * vec.z);
    float3 newVec = float3(vec.x / mag, vec.y / mag, vec.z / mag);
    return newVec;
}

//Same as the Vector3.magnitude method in unity
float VectorMagnitude(float3 vec)
{
    return sqrt(vec.x * vec.x + vec.y * vec.y + vec.z * vec.z);
}

//some Mathf constants
#define PI 3.14159265358979323846
#define Deg2Rad (PI * 2) / 360.0
#define Rad2Deg 360 / (PI * 2)

//ensures that degree values are between 0 and 360
float Degrees360(float angleDegrees)
{
    float ad = angleDegrees;
    while (ad >= 360)
    {
        ad -= 360;
    }
    while (ad < 0)
    {
        ad += 360;
    }
    return ad;

}

//coverts a vector to head
float VectorToHeadingDegrees(float3 v)
{
    return atan2(v.x, v.z) * Rad2Deg;
}

//gets difference between angles
float AngleDiffPosNeg(float a, float b)
{
    float diff = a - b;
    if (diff > 180)
        return diff - 360;
    if (diff < -180)
        return diff + 360;
    return diff;
}

float logBase(float num, float base)
{
    return log(num) / log(base);
}

/*calculates the potential value for a specific postion
NOTE: this function reflects the ComputePotentialDHDS() method in Move.cs, if the code in that function is changed
the code in this function should be changed to give an accurate representation of fields
*/
float CalculatePotential(float3 position, int entity)
{
    float magnitude = 0;
    
    float3 attractiveDist;
    float3 attractivePotential;
    
    if (entCommands != 0)
    {
        attractiveDist = ships[entity].movePosition - position;
        attractivePotential = NormalizeVector(attractiveDist) *
            waypointCoefficient * pow(VectorMagnitude(attractiveDist), waypointExponent);
    }
    else
    {
        attractivePotential = float3(0, 0, 0);
    }
    
    float3 repField = 0;
    float3 attField = 0;
    float3 crossPosField = 0;
    float3 crossVelField = 0;
    
    float3 starboard = NormalizeVector(cross(ships[entity].velocity, float3(0, -1, 0)));
    
    for (int i = 0; i < numShips; i++)
    {
        if (i == entity)
            continue;
        
        float3 posDiff = ships[i].position - position;
        float3 relVel = ships[i].velocity - ships[entity].velocity;
        
        float3 entPosDiff = ships[i].position - ships[entity].position;
        float relBearing = atan2(entPosDiff.x, entPosDiff.z) * Rad2Deg - ships[entity].heading;
        float3 negEntPosDiff = ships[entity].position - ships[i].position;
        float targetAngle = atan2(negEntPosDiff.x, negEntPosDiff.z) * Rad2Deg - ships[i].heading;
        
        float bAngle = sin((relBearing + bearingAngle) * Deg2Rad);
        float tAngle = sin((targetAngle + taAngle) * Deg2Rad);
        
        repField = repField + (pow(VectorMagnitude(posDiff), repulsiveExponent) * repulsiveCoefficient * -NormalizeVector(posDiff));
        attField = attField + (pow(VectorMagnitude(posDiff), attractiveExponent) * attractiveCoefficient * NormalizeVector(posDiff));
        crossPosField = crossPosField + (pow((0.5 * (bAngle + 1)), bearingAngleExp) * pow(VectorMagnitude(entPosDiff), bearingExponent) * bearingCoefficient * starboard);
        crossVelField = crossVelField + (pow((0.5 * (tAngle + 1)), taAngle) * pow(VectorMagnitude(entPosDiff), taExponent) * taCoefficient * starboard);
    }
    
    float3 starboardPosition = ships[entity].position + (300 * starboard);
    
    float starboardDistance = 0;
    starboardDistance = VectorMagnitude(starboardPosition - position);
    
    if (calcWaypoint)
        magnitude = magnitude - VectorMagnitude(attractivePotential);
    if (calcRepField)
        magnitude = magnitude + VectorMagnitude(repField);
    if (calcAttField)
        magnitude = magnitude - VectorMagnitude(attField);
    
    if (starboardDistance < 100)
    {
        if (calcCrossPosField)
            magnitude = magnitude - VectorMagnitude(crossPosField);
        if (calcCrossVelField)
            magnitude = magnitude - VectorMagnitude(crossVelField);
    }
    
    magnitude = clamp(magnitude, -maxMag, maxMag);
    
    return magnitude;
}

//function that calculates the potential at all points in the mesh and updates the buffer to be read back
[numthreads(64, 1, 1)]
void FunctionKernel(uint3 id : SV_DispatchThreadID)
{
    if (logarthmic)
    {
        float3 pos = positions[id.x];
        pos.y = 0;
        float mag = (CalculatePotential(pos, entity) / maxMag) * 400;
    
        positions[id.x] = float3(pos.x, mag, pos.z);
    }
    else
    {
        float3 pos = positions[id.x];
        bool negative = false;
        pos.y = 0;
        float potential = CalculatePotential(pos, entity);
        if (potential < 0)
            negative = true;
        potential = abs(potential) + 1;
        float mag = 60 * (logBase(potential, 10) / maxMag) * 400;
    
        mag = clamp(mag, 0, 400);
    
        if (negative)
            positions[id.x] = float3(pos.x, -mag, pos.z);
        else
            positions[id.x] = float3(pos.x, mag, pos.z);
    }
    
}

 /*
    float3 pos = positions[id.x];
    bool negative = false;
    pos.y = 0;
    float potential = CalculatePotential(pos, entity);
    if (potential < 0)
        negative = true;
    potential = abs(potential) + 1;
    float mag = 60 * (logBase(potential, 10) / maxMag) * 400;
    
    mag = clamp(mag, 0, 400);
    
    if (negative)
        positions[id.x] = float3(pos.x, -mag, pos.z);
    else
        positions[id.x] = float3(pos.x, mag, pos.z);
    
    float logBase(float num, float base)
{
    return log(num) / log(base);
}

float3 pos = positions[id.x];
    pos.y = 0;
    float mag = (CalculatePotential(pos, entity) / maxMag) * 400;
    
    positions[id.x] = float3(pos.x, mag, pos.z);
    */